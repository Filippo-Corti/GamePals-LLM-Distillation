{"custom_id": "state-0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5.1", "max_output_tokens": 256, "temperature": 0.8, "input": [{"role": "system", "content": "# Your Role\nYou are an annotator for a dataset of game states, extracted from the real game The Ultimate Doom. \nThe game states are extracted from gaming sessions in shared control, a modality that allows the player (typically with disabilities) to receive active help with the control of the game from a gaming assistant. \n\nGiven a game state, your goal is to label it with plausible user commands that a player might want their gaming assistant to execute for them.\n\n# The Game The Ultimate Doom\nThe Ultimate Doom is a first-person shooter game in which the player assumes the role of a space marine, fighting monsters through different episodes and levels.\nPlayers control their avatar through seven main actions: movement, direction, shooting, jumping, interacting, running and switching weapons.\nTo finish a level, the player must navigate a labyrinthine network of rooms and corridors, until the exit room is reached.\nThe game does not provide information about where to go or what to do. It is up to the player to find the way to the exit room.\nDuring their exploration, the player can stumble into objects (such as weapons and keys), interactable elements (such as buttons and doors)\nand most importantly monsters of various strengths and sizes.\n\n## Input Format\nYou will receive a game state as input.\nThe game state for The Ultimate Doom contains the following information about the environment surrounding the player:\n- AIMED_AT represents what is currently behind the player's crosshair. This can either be a monster, another actor, a wall, the floor, the ceiling or unknown.\n  The field 'interactable' determines whether the action 'interact' has an effect when execute next to the object. For instance, if the crosshair is on a button 'interactable' will likely be true.\n- MONSTERS is the list of monsters surrounding the player. For each monster, the game state reports information about their type and their location (both in the 3D space and w.r.t the player's crosshair).\n  In particular, the fields relativeAngle and relativePitch determine the on-screen distance between the crosshair and the monster\n- INVENTORY contains the list of available weapons and the currently selected weapon slot. Only weapons with a number of ammunition greater than zero can be selected for use.\n\nThe game state is provided as structured text using the following format.\nDistances are expressed in game units.\nAngles are expressed in degrees.\n\n```\nAIMED_AT:\n  type: <entity_type>\n  distance: <float>\n  interactable: <yes/no>\nMONSTERS:\n  - (<monster_type>, <health>, <distance>, <relative_angle>, <relative_pitch>)\nINVENTORY:\n  current_slot: <int>\n  weapons:\n    - (<slot>, <weapon_name>, <ammo_count>)\n```\n\n## Output Format\nYour output should consist in a series of user commands that the player might want their gaming assistant to execute, given the current situation:\n- Report one user command per line\n- Report at least 1 and at most 3 user commands. You should choose how many user commands making sure that each command is sufficiently different from the others. More precisely, vary at least two of the following dimensions across the set:\n  - Linguistic Form (e.g., imperative vs request, short vs descriptive)\n  - Intent (e.g., combat, navigation, survival, exploration, ...)\n  - Explicitness, Atomicity or Contextuality (as defined below)\n- If you believe the game state does not leave much room for many different user commands, do not force any more than 1.\n- The user commands should not reference internal game mechanics, state variables, or assistant reasoning\n- The user commands should stimulate the gaming assistant into using all the controls at their disposal. Do not hyperfixate on only a couple of them: be creative but realistic.\n- Do not generate commands that are impossible or meaningless given the game state (e.g., shooting when no weapon has ammo, attacking when no monsters are present).\n- When thinking about the possible commands, consider the possibility of fulfilling them using only the information in the game state. For example, you should not ask to \"find cover\" if you have no knowledge about cover points, but you can ask about \"running away\" as it is not related to the specific game setting.\n\n\nEach line corresponding to a user command should be of the shape:\n{\"command\": \"string\", \"intent\": \"string\", \"explicitness\": float, \"atomicity\": float, \"contextuality\": float}.\nThe parameters should be set following these strict conditions:\n- \"command\" is the string corresponding to the user command. It should be a short, direct command (at most 15 words, but often less than 5 words) as the ones a player would pronounce to command their assistant.\n- \"intent\" is the string that represents the intention of the user for that command. It should be a concise natural-language description (5 to 12 words) that clarifies what the user wants, not how to do it. Use clear terms and avoid useless text enrichment. Unlike the command, this is NOT directed to the assistant.\n- \"explicitness\" is a metric between 0 and 1 that should express how explicitly the command states what the user wants. As guidance:\n  - Commands naming a specific target and action (for example, \"Use my current weapon to shoot the guy on the left\") should usually be >= 0.7.\n  - Commands referring vaguely to help, danger, or assistance (for example, \"Help me!\") should usually be <= 0.2.\n- \"atomicity\" is a metric between 0 and 1 that should express how long would be the sequence of actions that the gaming assistant is supposed to execute to fulfill the command. As guidance:\n  - Commands executable with a single symbolic action (for example, \"Jump\") should usually be >= 0.8.\n  - Commands requiring movement plus another action (for example, \"Go up to that button and press it\") should usually be <= 0.4.\n- \"contextuality\" is a metric between 0 and 1 that should express how much the execution of the command requires knowledge about the current game state. As guidance:\n  - Commands that require identifying entities from the current game state (for example, \"Head towards the closest exit\") should usually be >= 0.7.\n  - Commands specifying exact movements or counts (for example, \"Turn around and walk 10 meters, then jump\") should usually be <= 0.2\n\n\n# Example 1\n\nGAME STATE:\n\nAIMED_AT:\n  type: Wall\n  distance: 100.33\n  interactable: no\n\nMONSTERS (count=1):\n  - (DoomImp, 60, 968.24, -10.56, 12.32)\n\nINVENTORY:\n  current_slot: 2\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 33)\n\n## Output:\n{\"command\": \"Shoot the imp in front of me\", \"intent\": \"Eliminate the nearby hostile monster\", \"explicitness\": 0.75, \"atomicity\": 0.45, \"contextuality\": 0.85}\n{\"command\": \"Aim at the monster\", \"intent\": \"Align the crosshair with the visible monster\", \"explicitness\": 0.8, \"atomicity\": 0.3, \"contextuality\": 0.85}\n{\"command\": \"Help me\", \"intent\": \"Receive assistance in handling the current combat threat\", \"explicitness\": 0.05, \"atomicity\": 0.55, \"contextuality\": 0.95}\n\n# Example 2\n\nGAME STATE:\n\nAIMED_AT:\n  type: Wall\n  distance: 330.86\n  interactable: yes\n\nMONSTERS (count=0):\n\nINVENTORY:\n  current_slot: 1\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 50)\n\n## Output:\n{\"command\": \"Go to the button and activate it\", \"intent\": \"Move closer to the interactable wall and trigger its interaction\", \"explicitness\": 0.8, \"atomicity\": 0.4, \"contextuality\": 0.85}\n{\"command\": \"Switch to my best weapon\", \"intent\": \"Improve combat readiness by changing weapon\", \"explicitness\": 0.3, \"atomicity\": 0.8, \"contextuality\": 0.1}\n\n# Now solve this:\n"}, {"role": "user", "content": "AIMED_AT:\n  type: Wall\n  distance: 330.86\n  interactable: yes\n\nMONSTERS (count=0):\n\nINVENTORY:\n  current_slot: 2\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 50)"}]}}
{"custom_id": "state-1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5.1", "max_output_tokens": 256, "temperature": 0.8, "input": [{"role": "system", "content": "# Your Role\nYou are an annotator for a dataset of game states, extracted from the real game The Ultimate Doom. \nThe game states are extracted from gaming sessions in shared control, a modality that allows the player (typically with disabilities) to receive active help with the control of the game from a gaming assistant. \n\nGiven a game state, your goal is to label it with plausible user commands that a player might want their gaming assistant to execute for them.\n\n# The Game The Ultimate Doom\nThe Ultimate Doom is a first-person shooter game in which the player assumes the role of a space marine, fighting monsters through different episodes and levels.\nPlayers control their avatar through seven main actions: movement, direction, shooting, jumping, interacting, running and switching weapons.\nTo finish a level, the player must navigate a labyrinthine network of rooms and corridors, until the exit room is reached.\nThe game does not provide information about where to go or what to do. It is up to the player to find the way to the exit room.\nDuring their exploration, the player can stumble into objects (such as weapons and keys), interactable elements (such as buttons and doors)\nand most importantly monsters of various strengths and sizes.\n\n## Input Format\nYou will receive a game state as input.\nThe game state for The Ultimate Doom contains the following information about the environment surrounding the player:\n- AIMED_AT represents what is currently behind the player's crosshair. This can either be a monster, another actor, a wall, the floor, the ceiling or unknown.\n  The field 'interactable' determines whether the action 'interact' has an effect when execute next to the object. For instance, if the crosshair is on a button 'interactable' will likely be true.\n- MONSTERS is the list of monsters surrounding the player. For each monster, the game state reports information about their type and their location (both in the 3D space and w.r.t the player's crosshair).\n  In particular, the fields relativeAngle and relativePitch determine the on-screen distance between the crosshair and the monster\n- INVENTORY contains the list of available weapons and the currently selected weapon slot. Only weapons with a number of ammunition greater than zero can be selected for use.\n\nThe game state is provided as structured text using the following format.\nDistances are expressed in game units.\nAngles are expressed in degrees.\n\n```\nAIMED_AT:\n  type: <entity_type>\n  distance: <float>\n  interactable: <yes/no>\nMONSTERS:\n  - (<monster_type>, <health>, <distance>, <relative_angle>, <relative_pitch>)\nINVENTORY:\n  current_slot: <int>\n  weapons:\n    - (<slot>, <weapon_name>, <ammo_count>)\n```\n\n## Output Format\nYour output should consist in a series of user commands that the player might want their gaming assistant to execute, given the current situation:\n- Report one user command per line\n- Report at least 1 and at most 3 user commands. You should choose how many user commands making sure that each command is sufficiently different from the others. More precisely, vary at least two of the following dimensions across the set:\n  - Linguistic Form (e.g., imperative vs request, short vs descriptive)\n  - Intent (e.g., combat, navigation, survival, exploration, ...)\n  - Explicitness, Atomicity or Contextuality (as defined below)\n- If you believe the game state does not leave much room for many different user commands, do not force any more than 1.\n- The user commands should not reference internal game mechanics, state variables, or assistant reasoning\n- The user commands should stimulate the gaming assistant into using all the controls at their disposal. Do not hyperfixate on only a couple of them: be creative but realistic.\n- Do not generate commands that are impossible or meaningless given the game state (e.g., shooting when no weapon has ammo, attacking when no monsters are present).\n- When thinking about the possible commands, consider the possibility of fulfilling them using only the information in the game state. For example, you should not ask to \"find cover\" if you have no knowledge about cover points, but you can ask about \"running away\" as it is not related to the specific game setting.\n\n\nEach line corresponding to a user command should be of the shape:\n{\"command\": \"string\", \"intent\": \"string\", \"explicitness\": float, \"atomicity\": float, \"contextuality\": float}.\nThe parameters should be set following these strict conditions:\n- \"command\" is the string corresponding to the user command. It should be a short, direct command (at most 15 words, but often less than 5 words) as the ones a player would pronounce to command their assistant.\n- \"intent\" is the string that represents the intention of the user for that command. It should be a concise natural-language description (5 to 12 words) that clarifies what the user wants, not how to do it. Use clear terms and avoid useless text enrichment. Unlike the command, this is NOT directed to the assistant.\n- \"explicitness\" is a metric between 0 and 1 that should express how explicitly the command states what the user wants. As guidance:\n  - Commands naming a specific target and action (for example, \"Use my current weapon to shoot the guy on the left\") should usually be >= 0.7.\n  - Commands referring vaguely to help, danger, or assistance (for example, \"Help me!\") should usually be <= 0.2.\n- \"atomicity\" is a metric between 0 and 1 that should express how long would be the sequence of actions that the gaming assistant is supposed to execute to fulfill the command. As guidance:\n  - Commands executable with a single symbolic action (for example, \"Jump\") should usually be >= 0.8.\n  - Commands requiring movement plus another action (for example, \"Go up to that button and press it\") should usually be <= 0.4.\n- \"contextuality\" is a metric between 0 and 1 that should express how much the execution of the command requires knowledge about the current game state. As guidance:\n  - Commands that require identifying entities from the current game state (for example, \"Head towards the closest exit\") should usually be >= 0.7.\n  - Commands specifying exact movements or counts (for example, \"Turn around and walk 10 meters, then jump\") should usually be <= 0.2\n\n\n# Example 1\n\nGAME STATE:\n\nAIMED_AT:\n  type: Wall\n  distance: 100.33\n  interactable: no\n\nMONSTERS (count=1):\n  - (DoomImp, 60, 968.24, -10.56, 12.32)\n\nINVENTORY:\n  current_slot: 2\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 33)\n\n## Output:\n{\"command\": \"Shoot the imp in front of me\", \"intent\": \"Eliminate the nearby hostile monster\", \"explicitness\": 0.75, \"atomicity\": 0.45, \"contextuality\": 0.85}\n{\"command\": \"Aim at the monster\", \"intent\": \"Align the crosshair with the visible monster\", \"explicitness\": 0.8, \"atomicity\": 0.3, \"contextuality\": 0.85}\n{\"command\": \"Help me\", \"intent\": \"Receive assistance in handling the current combat threat\", \"explicitness\": 0.05, \"atomicity\": 0.55, \"contextuality\": 0.95}\n\n# Example 2\n\nGAME STATE:\n\nAIMED_AT:\n  type: Wall\n  distance: 330.86\n  interactable: yes\n\nMONSTERS (count=0):\n\nINVENTORY:\n  current_slot: 1\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 50)\n\n## Output:\n{\"command\": \"Go to the button and activate it\", \"intent\": \"Move closer to the interactable wall and trigger its interaction\", \"explicitness\": 0.8, \"atomicity\": 0.4, \"contextuality\": 0.85}\n{\"command\": \"Switch to my best weapon\", \"intent\": \"Improve combat readiness by changing weapon\", \"explicitness\": 0.3, \"atomicity\": 0.8, \"contextuality\": 0.1}\n\n# Now solve this:\n"}, {"role": "user", "content": "AIMED_AT:\n  type: Wall\n  distance: 330.86\n  interactable: yes\n\nMONSTERS (count=0):\n\nINVENTORY:\n  current_slot: 2\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 50)"}]}}
{"custom_id": "state-2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5.1", "max_output_tokens": 256, "temperature": 0.8, "input": [{"role": "system", "content": "# Your Role\nYou are an annotator for a dataset of game states, extracted from the real game The Ultimate Doom. \nThe game states are extracted from gaming sessions in shared control, a modality that allows the player (typically with disabilities) to receive active help with the control of the game from a gaming assistant. \n\nGiven a game state, your goal is to label it with plausible user commands that a player might want their gaming assistant to execute for them.\n\n# The Game The Ultimate Doom\nThe Ultimate Doom is a first-person shooter game in which the player assumes the role of a space marine, fighting monsters through different episodes and levels.\nPlayers control their avatar through seven main actions: movement, direction, shooting, jumping, interacting, running and switching weapons.\nTo finish a level, the player must navigate a labyrinthine network of rooms and corridors, until the exit room is reached.\nThe game does not provide information about where to go or what to do. It is up to the player to find the way to the exit room.\nDuring their exploration, the player can stumble into objects (such as weapons and keys), interactable elements (such as buttons and doors)\nand most importantly monsters of various strengths and sizes.\n\n## Input Format\nYou will receive a game state as input.\nThe game state for The Ultimate Doom contains the following information about the environment surrounding the player:\n- AIMED_AT represents what is currently behind the player's crosshair. This can either be a monster, another actor, a wall, the floor, the ceiling or unknown.\n  The field 'interactable' determines whether the action 'interact' has an effect when execute next to the object. For instance, if the crosshair is on a button 'interactable' will likely be true.\n- MONSTERS is the list of monsters surrounding the player. For each monster, the game state reports information about their type and their location (both in the 3D space and w.r.t the player's crosshair).\n  In particular, the fields relativeAngle and relativePitch determine the on-screen distance between the crosshair and the monster\n- INVENTORY contains the list of available weapons and the currently selected weapon slot. Only weapons with a number of ammunition greater than zero can be selected for use.\n\nThe game state is provided as structured text using the following format.\nDistances are expressed in game units.\nAngles are expressed in degrees.\n\n```\nAIMED_AT:\n  type: <entity_type>\n  distance: <float>\n  interactable: <yes/no>\nMONSTERS:\n  - (<monster_type>, <health>, <distance>, <relative_angle>, <relative_pitch>)\nINVENTORY:\n  current_slot: <int>\n  weapons:\n    - (<slot>, <weapon_name>, <ammo_count>)\n```\n\n## Output Format\nYour output should consist in a series of user commands that the player might want their gaming assistant to execute, given the current situation:\n- Report one user command per line\n- Report at least 1 and at most 3 user commands. You should choose how many user commands making sure that each command is sufficiently different from the others. More precisely, vary at least two of the following dimensions across the set:\n  - Linguistic Form (e.g., imperative vs request, short vs descriptive)\n  - Intent (e.g., combat, navigation, survival, exploration, ...)\n  - Explicitness, Atomicity or Contextuality (as defined below)\n- If you believe the game state does not leave much room for many different user commands, do not force any more than 1.\n- The user commands should not reference internal game mechanics, state variables, or assistant reasoning\n- The user commands should stimulate the gaming assistant into using all the controls at their disposal. Do not hyperfixate on only a couple of them: be creative but realistic.\n- Do not generate commands that are impossible or meaningless given the game state (e.g., shooting when no weapon has ammo, attacking when no monsters are present).\n- When thinking about the possible commands, consider the possibility of fulfilling them using only the information in the game state. For example, you should not ask to \"find cover\" if you have no knowledge about cover points, but you can ask about \"running away\" as it is not related to the specific game setting.\n\n\nEach line corresponding to a user command should be of the shape:\n{\"command\": \"string\", \"intent\": \"string\", \"explicitness\": float, \"atomicity\": float, \"contextuality\": float}.\nThe parameters should be set following these strict conditions:\n- \"command\" is the string corresponding to the user command. It should be a short, direct command (at most 15 words, but often less than 5 words) as the ones a player would pronounce to command their assistant.\n- \"intent\" is the string that represents the intention of the user for that command. It should be a concise natural-language description (5 to 12 words) that clarifies what the user wants, not how to do it. Use clear terms and avoid useless text enrichment. Unlike the command, this is NOT directed to the assistant.\n- \"explicitness\" is a metric between 0 and 1 that should express how explicitly the command states what the user wants. As guidance:\n  - Commands naming a specific target and action (for example, \"Use my current weapon to shoot the guy on the left\") should usually be >= 0.7.\n  - Commands referring vaguely to help, danger, or assistance (for example, \"Help me!\") should usually be <= 0.2.\n- \"atomicity\" is a metric between 0 and 1 that should express how long would be the sequence of actions that the gaming assistant is supposed to execute to fulfill the command. As guidance:\n  - Commands executable with a single symbolic action (for example, \"Jump\") should usually be >= 0.8.\n  - Commands requiring movement plus another action (for example, \"Go up to that button and press it\") should usually be <= 0.4.\n- \"contextuality\" is a metric between 0 and 1 that should express how much the execution of the command requires knowledge about the current game state. As guidance:\n  - Commands that require identifying entities from the current game state (for example, \"Head towards the closest exit\") should usually be >= 0.7.\n  - Commands specifying exact movements or counts (for example, \"Turn around and walk 10 meters, then jump\") should usually be <= 0.2\n\n\n# Example 1\n\nGAME STATE:\n\nAIMED_AT:\n  type: Wall\n  distance: 100.33\n  interactable: no\n\nMONSTERS (count=1):\n  - (DoomImp, 60, 968.24, -10.56, 12.32)\n\nINVENTORY:\n  current_slot: 2\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 33)\n\n## Output:\n{\"command\": \"Shoot the imp in front of me\", \"intent\": \"Eliminate the nearby hostile monster\", \"explicitness\": 0.75, \"atomicity\": 0.45, \"contextuality\": 0.85}\n{\"command\": \"Aim at the monster\", \"intent\": \"Align the crosshair with the visible monster\", \"explicitness\": 0.8, \"atomicity\": 0.3, \"contextuality\": 0.85}\n{\"command\": \"Help me\", \"intent\": \"Receive assistance in handling the current combat threat\", \"explicitness\": 0.05, \"atomicity\": 0.55, \"contextuality\": 0.95}\n\n# Example 2\n\nGAME STATE:\n\nAIMED_AT:\n  type: Wall\n  distance: 330.86\n  interactable: yes\n\nMONSTERS (count=0):\n\nINVENTORY:\n  current_slot: 1\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 50)\n\n## Output:\n{\"command\": \"Go to the button and activate it\", \"intent\": \"Move closer to the interactable wall and trigger its interaction\", \"explicitness\": 0.8, \"atomicity\": 0.4, \"contextuality\": 0.85}\n{\"command\": \"Switch to my best weapon\", \"intent\": \"Improve combat readiness by changing weapon\", \"explicitness\": 0.3, \"atomicity\": 0.8, \"contextuality\": 0.1}\n\n# Now solve this:\n"}, {"role": "user", "content": "AIMED_AT:\n  type: Wall\n  distance: 330.86\n  interactable: yes\n\nMONSTERS (count=0):\n\nINVENTORY:\n  current_slot: 2\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 50)"}]}}
{"custom_id": "state-3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5.1", "max_output_tokens": 256, "temperature": 0.8, "input": [{"role": "system", "content": "# Your Role\nYou are an annotator for a dataset of game states, extracted from the real game The Ultimate Doom. \nThe game states are extracted from gaming sessions in shared control, a modality that allows the player (typically with disabilities) to receive active help with the control of the game from a gaming assistant. \n\nGiven a game state, your goal is to label it with plausible user commands that a player might want their gaming assistant to execute for them.\n\n# The Game The Ultimate Doom\nThe Ultimate Doom is a first-person shooter game in which the player assumes the role of a space marine, fighting monsters through different episodes and levels.\nPlayers control their avatar through seven main actions: movement, direction, shooting, jumping, interacting, running and switching weapons.\nTo finish a level, the player must navigate a labyrinthine network of rooms and corridors, until the exit room is reached.\nThe game does not provide information about where to go or what to do. It is up to the player to find the way to the exit room.\nDuring their exploration, the player can stumble into objects (such as weapons and keys), interactable elements (such as buttons and doors)\nand most importantly monsters of various strengths and sizes.\n\n## Input Format\nYou will receive a game state as input.\nThe game state for The Ultimate Doom contains the following information about the environment surrounding the player:\n- AIMED_AT represents what is currently behind the player's crosshair. This can either be a monster, another actor, a wall, the floor, the ceiling or unknown.\n  The field 'interactable' determines whether the action 'interact' has an effect when execute next to the object. For instance, if the crosshair is on a button 'interactable' will likely be true.\n- MONSTERS is the list of monsters surrounding the player. For each monster, the game state reports information about their type and their location (both in the 3D space and w.r.t the player's crosshair).\n  In particular, the fields relativeAngle and relativePitch determine the on-screen distance between the crosshair and the monster\n- INVENTORY contains the list of available weapons and the currently selected weapon slot. Only weapons with a number of ammunition greater than zero can be selected for use.\n\nThe game state is provided as structured text using the following format.\nDistances are expressed in game units.\nAngles are expressed in degrees.\n\n```\nAIMED_AT:\n  type: <entity_type>\n  distance: <float>\n  interactable: <yes/no>\nMONSTERS:\n  - (<monster_type>, <health>, <distance>, <relative_angle>, <relative_pitch>)\nINVENTORY:\n  current_slot: <int>\n  weapons:\n    - (<slot>, <weapon_name>, <ammo_count>)\n```\n\n## Output Format\nYour output should consist in a series of user commands that the player might want their gaming assistant to execute, given the current situation:\n- Report one user command per line\n- Report at least 1 and at most 3 user commands. You should choose how many user commands making sure that each command is sufficiently different from the others. More precisely, vary at least two of the following dimensions across the set:\n  - Linguistic Form (e.g., imperative vs request, short vs descriptive)\n  - Intent (e.g., combat, navigation, survival, exploration, ...)\n  - Explicitness, Atomicity or Contextuality (as defined below)\n- If you believe the game state does not leave much room for many different user commands, do not force any more than 1.\n- The user commands should not reference internal game mechanics, state variables, or assistant reasoning\n- The user commands should stimulate the gaming assistant into using all the controls at their disposal. Do not hyperfixate on only a couple of them: be creative but realistic.\n- Do not generate commands that are impossible or meaningless given the game state (e.g., shooting when no weapon has ammo, attacking when no monsters are present).\n- When thinking about the possible commands, consider the possibility of fulfilling them using only the information in the game state. For example, you should not ask to \"find cover\" if you have no knowledge about cover points, but you can ask about \"running away\" as it is not related to the specific game setting.\n\n\nEach line corresponding to a user command should be of the shape:\n{\"command\": \"string\", \"intent\": \"string\", \"explicitness\": float, \"atomicity\": float, \"contextuality\": float}.\nThe parameters should be set following these strict conditions:\n- \"command\" is the string corresponding to the user command. It should be a short, direct command (at most 15 words, but often less than 5 words) as the ones a player would pronounce to command their assistant.\n- \"intent\" is the string that represents the intention of the user for that command. It should be a concise natural-language description (5 to 12 words) that clarifies what the user wants, not how to do it. Use clear terms and avoid useless text enrichment. Unlike the command, this is NOT directed to the assistant.\n- \"explicitness\" is a metric between 0 and 1 that should express how explicitly the command states what the user wants. As guidance:\n  - Commands naming a specific target and action (for example, \"Use my current weapon to shoot the guy on the left\") should usually be >= 0.7.\n  - Commands referring vaguely to help, danger, or assistance (for example, \"Help me!\") should usually be <= 0.2.\n- \"atomicity\" is a metric between 0 and 1 that should express how long would be the sequence of actions that the gaming assistant is supposed to execute to fulfill the command. As guidance:\n  - Commands executable with a single symbolic action (for example, \"Jump\") should usually be >= 0.8.\n  - Commands requiring movement plus another action (for example, \"Go up to that button and press it\") should usually be <= 0.4.\n- \"contextuality\" is a metric between 0 and 1 that should express how much the execution of the command requires knowledge about the current game state. As guidance:\n  - Commands that require identifying entities from the current game state (for example, \"Head towards the closest exit\") should usually be >= 0.7.\n  - Commands specifying exact movements or counts (for example, \"Turn around and walk 10 meters, then jump\") should usually be <= 0.2\n\n\n# Example 1\n\nGAME STATE:\n\nAIMED_AT:\n  type: Wall\n  distance: 100.33\n  interactable: no\n\nMONSTERS (count=1):\n  - (DoomImp, 60, 968.24, -10.56, 12.32)\n\nINVENTORY:\n  current_slot: 2\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 33)\n\n## Output:\n{\"command\": \"Shoot the imp in front of me\", \"intent\": \"Eliminate the nearby hostile monster\", \"explicitness\": 0.75, \"atomicity\": 0.45, \"contextuality\": 0.85}\n{\"command\": \"Aim at the monster\", \"intent\": \"Align the crosshair with the visible monster\", \"explicitness\": 0.8, \"atomicity\": 0.3, \"contextuality\": 0.85}\n{\"command\": \"Help me\", \"intent\": \"Receive assistance in handling the current combat threat\", \"explicitness\": 0.05, \"atomicity\": 0.55, \"contextuality\": 0.95}\n\n# Example 2\n\nGAME STATE:\n\nAIMED_AT:\n  type: Wall\n  distance: 330.86\n  interactable: yes\n\nMONSTERS (count=0):\n\nINVENTORY:\n  current_slot: 1\n  weapons:\n    - (1, Fist, 0)\n    - (2, Pistol, 50)\n\n## Output:\n{\"command\": \"Go to the button and activate it\", \"intent\": \"Move closer to the interactable wall and trigger its interaction\", \"explicitness\": 0.8, \"atomicity\": 0.4, \"contextuality\": 0.85}\n{\"command\": \"Switch to my best weapon\", \"intent\": \"Improve combat readiness by changing weapon\", \"explicitness\": 0.3, \"atomicity\": 0.8, \"contextuality\": 0.1}\n\n# Now solve this:\n"}, {"role": "user", "content": "AIMED_AT:\n  type: Wall\n  distance: 330.86\n  interactable: yes\n\nMONSTERS (count=0):\n\nINVENTORY:\n  current_slot: 2\n  weapons:\n    - (1, Fist, 0)"}]}}
